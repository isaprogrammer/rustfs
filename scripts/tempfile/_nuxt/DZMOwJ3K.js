import{M as r}from"./BvexhTZs.js";const o=()=>{const{$api:s}=r();return{async getKMSStatus(){return await s.get("/kms/service-status")},async configureKMS(e){if(e.backend_type==="vault"||!e.backend_type){const t={backend_type:"vault",address:e.address||e.backend?.address,mount_path:e.mount_path||e.backend?.mount_path||"transit",kv_mount:e.kv_mount||e.backend?.kv_mount||"secret",key_path_prefix:e.key_path_prefix||e.backend?.key_path_prefix||"rustfs/kms/keys",default_key_id:e.default_key_id,timeout_seconds:e.timeout_seconds||30,retry_attempts:e.retry_attempts||3,enable_cache:e.enable_cache!==void 0?e.enable_cache:!0,cache_ttl_seconds:e.cache_ttl_seconds||600};if(e.auth_method||e.backend?.auth_method){const n=e.auth_method||e.backend.auth_method;n.token?t.auth_method={Token:{token:n.token}}:n.role_id&&n.secret_id&&(t.auth_method={AppRole:{role_id:n.role_id,secret_id:n.secret_id}})}return await s.post("/kms/configure",t)}else if(e.backend_type==="local"){const t={backend_type:"local",key_dir:e.key_directory||e.backend?.key_directory||"./kms_keys",master_key:e.master_key,default_key_id:e.default_key_id,timeout_seconds:e.timeout_seconds||30,retry_attempts:e.retry_attempts||3,enable_cache:e.enable_cache!==void 0?e.enable_cache:!0,cache_ttl_seconds:e.cache_ttl_seconds||600};return await s.post("/kms/configure",t)}else throw new Error(`Unsupported backend type: ${e.backend_type}`)},async startKMS(){return await s.post("/kms/start",{})},async stopKMS(){return await s.post("/kms/stop",{})},async reconfigureKMS(e){return await s.post("/kms/reconfigure",e)},async getConfiguration(){return await s.get("/kms/config")},async clearCache(){return await s.post("/kms/clear-cache",{})},async getDetailedStatus(){return await s.get("/kms/status")},async validateConfiguration(){try{const e=await this.getKMSStatus(),t=await this.getConfiguration();return{isValid:e.status==="Running"&&e.healthy===!0,status:e.status,healthy:e.healthy,hasConfig:!!t,issues:[]}}catch{return{isValid:!1,status:"Error",healthy:!1,hasConfig:!1,issues:["Failed to connect to KMS service"]}}},async createKey(e){const t={key_usage:e.KeyUsage||"EncryptDecrypt",description:e.Description,tags:e.Tags};return await s.post("/kms/keys",t)},async getKeyDetails(e){return await s.get(`/kms/keys/${e}`)},async getKeyList(e){const t=new URLSearchParams;e?.limit&&t.append("limit",e.limit.toString()),e?.marker&&t.append("marker",e.marker);const n=t.toString()?`/kms/keys?${t}`:"/kms/keys";return await s.get(n)},async deleteKey(e){const t=new URLSearchParams;t.append("keyId",e);const n=`/kms/keys/delete?${t.toString()}`;return await s.delete(n)},async forceDeleteKey(e){const t=new URLSearchParams;t.append("keyId",e),t.append("force_immediate","true");const n=`/kms/keys/delete?${t.toString()}`;return await s.delete(n)},async cancelKeyDeletion(e){return await s.post("/kms/keys/cancel-deletion",{key_id:e})},async generateDataKey(e){return await s.post("/kms/generate-data-key",e)},async decryptDataKey(e){throw console.warn("decryptDataKey should typically be called by RustFS server, not frontend"),new Error("Decrypt data key endpoint is not implemented yet. This is primarily for server-side use.")},async getStatus(){return await this.getKMSStatus()},async enableKey(e){throw console.warn("enableKey is deprecated. Key management should be done through AWS KMS-compatible APIs."),new Error("Key enable/disable functionality needs to be redesigned for new API")},async disableKey(e){throw console.warn("disableKey is deprecated. Key management should be done through AWS KMS-compatible APIs."),new Error("Key enable/disable functionality needs to be redesigned for new API")},async getKeyStatus(e){return console.warn("getKeyStatus is deprecated. Use getKeyDetails instead."),await this.getKeyDetails(e)}}};export{o as u};
